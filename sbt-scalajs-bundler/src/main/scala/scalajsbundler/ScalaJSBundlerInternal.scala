package scalajsbundler

import org.scalajs.core.tools.io.{FileVirtualJSFile, VirtualJSFile}
import org.scalajs.core.tools.javascript.Trees
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport._
import sbt.Keys._
import sbt._

import JS.syntax._

object ScalaJSBundlerInternal {

  import ScalaJSBundler.autoImport._

  // (file, mainClass)
  val scalaJSBundlerLauncher = taskKey[(File, String)]("Launcher generated by scalajs-bundler")

  // (scalajs.webpack.config.js, package.json, output files)
  val scalaJSBundlerConfigFiles = taskKey[(File, File, Seq[File])]("Writes the config files")

  private def perScalaJSStageSettings(stage: TaskKey[Attributed[File]]): Seq[Def.Setting[_]] =
    Seq(
      scalaJSLauncher in stage := Def.taskDyn(scalaJSLauncherTask(stage)).value,
      scalaJSBundlerLauncher in stage := Def.taskDyn(scalaJSBundlerLauncherTask(stage)).value,
      scalaJSBundlerConfigFiles in stage := Def.taskDyn(scalaJSBundlerConfigFilesTask(stage)).value,
      npmUpdate in stage := Def.taskDyn(npmUpdateTask(stage).dependsOn(scalaJSBundlerConfigFiles in stage)).value,
      webpackEntries in stage := Def.taskDyn(webpackEntriesSetting(stage)).value,
      relativeSourceMaps in stage := (emitSourceMaps in (webpack in stage)).value,
      webpack in stage := Def.taskDyn(bundleTask(stage).dependsOn(npmUpdate in stage)).value
    )

  private val perConfigSettings: Seq[Def.Setting[_]] =
    Seq(
      loadedJSEnv <<= loadedJSEnv.dependsOn(npmUpdate in fastOptJS),
      npmDependencies := Seq.empty,
      npmDevDependencies := Seq("webpack" -> (version in webpack).value),
      emitSourceMaps in (webpack in fullOptJS) := false,
      emitSourceMaps in (webpack in fastOptJS) := true
    ) ++
    perScalaJSStageSettings(fastOptJS) ++
    perScalaJSStageSettings(fullOptJS)

  private val testSettings: Seq[Setting[_]] =
    Seq(
      npmDependencies ++= (npmDependencies in Compile).value,
      npmDevDependencies ++= (npmDevDependencies in Compile).value
    )

  val projectSettings: Seq[Setting[_]] =
    Seq(
      version in webpack := "1.13",
      webpackConfigFile := None
    ) ++
    inConfig(Compile)(perConfigSettings) ++
    inConfig(Test)(perConfigSettings ++ testSettings)

  def scalaJSBundlerConfigFilesTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[(File, File, Seq[File])]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      // Create scalajs.webpack.config.js
      val scalajsConfigFile = targetDir / "scalajs.webpack.config.js"
      val scalajsConfigContent =
        JS.ref("module") `.` "exports" := JS.obj(Seq(
          "entry" -> JS.obj((webpackEntries in stage).value.map { case (key, file) =>
            key -> JS.str(file.absolutePath) }: _*
          ),
          "output" -> JS.obj(
            "path" -> JS.str(targetDir.absolutePath),
            "filename" -> JS.str("[name]-bundle.js")
          )
        ) ++ (
          if ((emitSourceMaps in (webpack in stage)).value) {
            Seq(
              "devtool" -> JS.str("source-map"),
              "module" -> JS.obj(
                "preLoaders" -> JS.arr(
                  JS.obj(
                    "test" -> JS.regex("\\.js$"),
                    "loader" -> JS.str("source-map-loader")
                  )
                )
              )
            )
          } else Nil
        ): _*)
      log.debug("Writing 'scalajs.webpack.config.js'")
      IO.write(scalajsConfigFile, scalajsConfigContent.show)


      def toJsonObject(deps: Seq[(String, String)]): Trees.ObjectConstr =
        JS.obj(deps.map { case (n, v) => (n, JS.str(v)) }: _*)

      // Create a package.json file
      val bundleCommand =
      (webpackConfigFile in stage).value match {
        case Some(configFile) =>
          val configFileCopy = targetDir / configFile.name
          IO.copyFile(configFile, configFileCopy)
          s"webpack --config ${configFileCopy.absolutePath}"
        case None =>
          s"webpack --config ${scalajsConfigFile.absolutePath}"
      }

      val devDependencies =
        if ((emitSourceMaps in (webpack in stage)).value) npmDevDependencies.value :+ ("source-map-loader" -> "0.1.5")
        else npmDevDependencies.value

      val packageJson =
        JS.obj(
          "dependencies" -> toJsonObject(npmDependencies.value),
          "devDependencies" -> toJsonObject(devDependencies),
          "scripts" -> JS.obj(
            "bundle" -> JS.str(bundleCommand)
          )
        )
      log.debug("Writing 'package.json'")
      val packageJsonFile = targetDir / "package.json"
      IO.write(packageJsonFile, JS.toJson(packageJson))

      val outputFiles =
        (webpackEntries in stage).value.map { case (key, _) => targetDir / s"$key-bundle.js" }

      (scalajsConfigFile, packageJsonFile, outputFiles)
    }

  // TODO remove as soon as they disappear from Scala.js
  def scalaJSBundlerLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[(File, String)]] =
    Def.task {
      val targetDir = (crossTarget in stage).value
      val stageOutput = stage.value.data

      val mainClassValue = (mainClass in (scalaJSLauncher in stage)).value.getOrElse("No main class detected")
      val launcherContent = {
        val module = JS.ref("require")(JS.str(stageOutput.absolutePath))
        val mainClassRef =
          mainClassValue
            .split('.')
            .foldLeft[Trees.Tree](module) { (tree, part) => tree.bracket(part) }
        (mainClassRef() `.` "main")()
      }
      val launcherFile = targetDir / "launcher.js"
      IO.write(launcherFile, launcherContent.show)

      (launcherFile, mainClassValue)
    }

  def scalaJSLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Attributed[VirtualJSFile]]] =
    Def.task {
      val (launcherFile, mainClassValue) = (scalaJSBundlerLauncher in stage).value

      Attributed[VirtualJSFile](FileVirtualJSFile(launcherFile))(
        AttributeMap.empty.put(name.key, mainClassValue)
      )
    }

  def npmUpdateTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Unit]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val cachedActionFunction =
        FileFunction.cached(
          streams.value.cacheDirectory / "npm-update",
          inStyle = FilesInfo.hash
        ) { _ =>
          log.info("Updating NPM dependencies")
          run("npm update", targetDir, log)
          Set.empty
        }

      cachedActionFunction(Set(targetDir /  "package.json"))
      ()

    }

  def webpackEntriesSetting(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[(String, File)]]] =
    Def.task {
      val launcherFile = (scalaJSBundlerLauncher in stage).value._1

      val stageFile = stage.value.data
      val name = stageFile.name.stripSuffix(".js")
      Seq(name -> launcherFile)
    }

  def bundleTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[File]]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value
      val configFiles = (scalaJSBundlerConfigFiles in stage).value
      val entries = (webpackEntries in stage).value

      val cachedActionFunction =
        FileFunction.cached(
          streams.value.cacheDirectory / s"${stage.key.label}-webpack",
          inStyle = FilesInfo.hash
        ) { in =>
          log.info("Bundling the application with its NPM dependencies")
          run("npm run bundle", targetDir, log)

          configFiles._3.to[Set] // TODO Support custom webpack config file (the output may be overridden by users)
        }
      cachedActionFunction(Set(
        configFiles._1,
        configFiles._2
      ) ++ entries.map(_._2).to[Set] + stage.value.data).to[Seq] // Note: the entries should be enough, excepted that they currently are launchers, which do not change even if the scalajs stage output changes
    }

  def run(cmd: String, cwd: File, logger: Logger): Unit = {
    val process = Process(cmd, cwd)
    process !! logger
    ()
  }
}
