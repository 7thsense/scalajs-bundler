package scalajsbundler

import org.scalajs.core.tools.io.{FileVirtualJSFile, VirtualJSFile}
import org.scalajs.core.tools.javascript.Trees
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport._
import sbt.Keys._
import sbt._

import JS.syntax._

object ScalaJSBundlerInternal {

  import ScalaJSBundler.autoImport._

  // (file, mainClass)
  val scalaJSBundlerLauncher = taskKey[(File, String)]("Launcher generated by scalajs-bundler")

  // (scalajs.webpack.config.js, package.json, output files)
  val scalaJSBundlerConfigFiles = taskKey[ScalaJSBundlerConfigFiles]("Writes the config files")

  val scalaJSBundlerManifest = taskKey[File]("Writes the NPM_DEPENDENCIES file")

  private def perScalaJSStageSettings(stage: TaskKey[Attributed[File]]): Seq[Def.Setting[_]] =
    Seq(
      scalaJSLauncher in stage := Def.taskDyn(scalaJSLauncherTask(stage)).value,
      scalaJSBundlerLauncher in stage := Def.taskDyn(scalaJSBundlerLauncherTask(stage)).value,
      scalaJSBundlerConfigFiles in stage := Def.taskDyn(scalaJSBundlerConfigFilesTask(stage)).value,
      npmUpdate in stage := Def.taskDyn(npmUpdateTask(stage).dependsOn(scalaJSBundlerConfigFiles in stage)).value,
      webpackEntries in stage := Def.taskDyn(webpackEntriesSetting(stage)).value,
      relativeSourceMaps in stage := (emitSourceMaps in (webpack in stage)).value,
      webpack in stage := Def.taskDyn(bundleTask(stage).dependsOn(npmUpdate in stage)).value
    )

  private val perConfigSettings: Seq[Def.Setting[_]] =
    Seq(
      loadedJSEnv <<= loadedJSEnv.dependsOn(npmUpdate in fastOptJS),
      npmDependencies := Seq.empty,
      npmDevDependencies := Seq.empty
    ) ++
    perScalaJSStageSettings(fastOptJS) ++
    perScalaJSStageSettings(fullOptJS)

  private val testSettings: Seq[Setting[_]] =
    Seq(
      npmDependencies ++= (npmDependencies in Compile).value,
      npmDevDependencies ++= (npmDevDependencies in Compile).value
    )

  val projectSettings: Seq[Setting[_]] =
    Seq(
      version in webpack := "1.13",
      webpackConfigFile := None,
      emitSourceMaps in (webpack in fullOptJS) := (emitSourceMaps in fullOptJS).value,
      emitSourceMaps in (webpack in fastOptJS) := (emitSourceMaps in fastOptJS).value,
      scalaJSBundlerManifest := scalaJSBundlerManifestTask.value,
      (products in Compile) <<= (products in Compile).dependsOn(scalaJSBundlerManifest)
    ) ++
    inConfig(Compile)(perConfigSettings) ++
    inConfig(Test)(perConfigSettings ++ testSettings)

  def scalaJSBundlerConfigFilesTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[ScalaJSBundlerConfigFiles]] =
    Def.task {
      ScalaJSBundlerConfigFiles.writeConfigFiles(
        streams.value.log,
        (crossTarget in stage).value,
        (version in webpack).value,
        (webpackConfigFile in stage).value,
        (webpackEntries in stage).value,
        (emitSourceMaps in (webpack in stage)).value,
        fullClasspath.value,
        npmDependencies.value,
        npmDevDependencies.value,
        configuration.value
      )
    }

  // TODO remove as soon as they disappear from Scala.js
  def scalaJSBundlerLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[(File, String)]] =
    Def.task {
      val targetDir = (crossTarget in stage).value
      val stageOutput = stage.value.data

      val mainClassValue = (mainClass in (scalaJSLauncher in stage)).value.getOrElse("No main class detected")
      val launcherContent = {
        val module = JS.ref("require")(JS.str(stageOutput.absolutePath))
        val mainClassRef =
          mainClassValue
            .split('.')
            .foldLeft[Trees.Tree](module) { (tree, part) => tree.bracket(part) }
        (mainClassRef() `.` "main")()
      }
      val launcherFile = targetDir / "launcher.js"
      IO.write(launcherFile, launcherContent.show)

      (launcherFile, mainClassValue)
    }

  def scalaJSLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Attributed[VirtualJSFile]]] =
    Def.task {
      val (launcherFile, mainClassValue) = (scalaJSBundlerLauncher in stage).value

      Attributed[VirtualJSFile](FileVirtualJSFile(launcherFile))(
        AttributeMap.empty.put(name.key, mainClassValue)
      )
    }

  def npmUpdateTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Unit]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val cachedActionFunction =
        FileFunction.cached(
          streams.value.cacheDirectory / "npm-update",
          inStyle = FilesInfo.hash
        ) { _ =>
          log.info("Updating NPM dependencies")
          run("npm update", targetDir, log)
          Set.empty
        }

      cachedActionFunction(Set(targetDir /  "package.json"))
      ()

    }

  def webpackEntriesSetting(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[(String, File)]]] =
    Def.task {
      val launcherFile = (scalaJSBundlerLauncher in stage).value._1

      val stageFile = stage.value.data
      val name = stageFile.name.stripSuffix(".js")
      Seq(name -> launcherFile)
    }

  def bundleTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[File]]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value
      val configFiles = (scalaJSBundlerConfigFiles in stage).value
      val entries = (webpackEntries in stage).value

      val cachedActionFunction =
        FileFunction.cached(
          streams.value.cacheDirectory / s"${stage.key.label}-webpack",
          inStyle = FilesInfo.hash
        ) { in =>
          log.info("Bundling the application with its NPM dependencies")
          run("npm run bundle", targetDir, log)

          configFiles.output.to[Set] // TODO Support custom webpack config file (the output may be overridden by users)
        }
      cachedActionFunction(Set(
        configFiles.webpackConfig,
        configFiles.packageJson
      ) ++ entries.map(_._2).to[Set] + stage.value.data).to[Seq] // Note: the entries should be enough, excepted that they currently are launchers, which do not change even if the scalajs stage output changes
    }

  def run(cmd: String, cwd: File, logger: Logger): Unit = {
    val process = Process(cmd, cwd)
    process !! logger
    ()
  }

  lazy val scalaJSBundlerManifestTask: Def.Initialize[Task[File]] =
    Def.task {
      NpmDependencies.writeManifest(
        NpmDependencies(
          (npmDependencies in Compile).value.to[List],
          (npmDependencies in Test).value.to[List],
          (npmDevDependencies in Compile).value.to[List],
          (npmDevDependencies in Test).value.to[List]
        ),
        (classDirectory in Compile).value
      )
    }

}
