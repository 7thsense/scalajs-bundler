package scalajsbundler

import org.scalajs.core.tools.io.{FileVirtualJSFile, VirtualJSFile}
import org.scalajs.core.tools.javascript.Trees
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport.{scalaJSLauncher, fastOptJS, fullOptJS, loadedJSEnv}
import sbt.Keys._
import sbt._

import JS.syntax._

object ScalaJSBundlerInternal {

  import ScalaJSBundler.autoImport._

  val scalaJSBundlerLauncher = taskKey[(File, String)]("Launcher generated by scalajs-bundler")

  private val perConfigSettings: Seq[Def.Setting[_]] =
    Seq(
      npmDependencies := Map.empty,
      npmDevDependencies := Map("webpack" -> webpackVersion.value),
      webpackSourceMap in fullOptJS := false,
      webpackSourceMap in fastOptJS := true,
      bundle := Def.taskDyn(bundleTask(fastOptJS)).value,
      bundleOpt := Def.taskDyn(bundleTask(fullOptJS)).value,
      npmUpdate in fastOptJS := Def.taskDyn(npmUpdateTask(fastOptJS)).value,
      npmUpdate in fullOptJS := Def.taskDyn(npmUpdateTask(fullOptJS)).value,
      scalaJSLauncher := Def.taskDyn(scalaJSLauncherTask(fastOptJS)).value,
      scalaJSBundlerLauncher := Def.taskDyn(scalaJSBundlerLauncherTask(fastOptJS)).value,
      loadedJSEnv <<= loadedJSEnv.dependsOn(npmUpdate in fastOptJS)
    )

  val testSettings: Seq[Setting[_]] =
    Seq(
      npmDependencies ++= (npmDependencies in Compile).value,
      npmDevDependencies ++= (npmDevDependencies in Compile).value
    )

  val projectSettings: Seq[Setting[_]] =
    Seq(
      webpackVersion := "1.13",
      webpackConfigFile := None
    ) ++
    inConfig(Compile)(perConfigSettings) ++
    inConfig(Test)(perConfigSettings ++ testSettings)

  def writeBuildFilesTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[File]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val stageOutput = stage.value.data

      val launcherFile = scalaJSBundlerLauncher.value._1
      val bundleFile = targetDir / (stageOutput.name.stripSuffix(".js") ++ "-bundle.js")

      // Create scalajs.webpack.config.js
      val scalajsConfigFile = targetDir / "scalajs.webpack.config.js"
      val scalajsConfigContent =
        JS.ref("module") `.` "exports" := JS.obj(
          "entry" -> JS.str(launcherFile.absolutePath),
          "output" -> JS.obj(
            "path" -> JS.str(targetDir.absolutePath),
            "filename" -> JS.str(bundleFile.name)
          )
        )
      log.debug("Writing 'scalajs.webpack.config.js'")
      IO.write(scalajsConfigFile, scalajsConfigContent.show)


      def toJsonObject(deps: Map[String, String]): Trees.ObjectConstr =
        JS.obj(deps.mapValues(JS.str).to[Seq]: _*)

      // Create a package.json file
      val bundleCommand =
      (webpackConfigFile in stage).value match {
        case Some(configFile) =>
          val configFileCopy = targetDir / configFile.name
          IO.copyFile(configFile, configFileCopy)
          s"webpack --config ${configFileCopy.absolutePath}"
        case None =>
          s"webpack --config ${scalajsConfigFile.absolutePath}"
      }

      val packageJson =
        JS.obj(
          "dependencies" -> toJsonObject(npmDependencies.value),
          "devDependencies" -> toJsonObject(npmDevDependencies.value),
          "scripts" -> JS.obj(
            "bundle" -> JS.str(bundleCommand)
          )
        )
      log.debug("Writing 'package.json'")
      IO.write(targetDir / "package.json", JS.toJson(packageJson))

      bundleFile
    }

  // TODO remove as soon as they disappear from Scala.js
  def scalaJSBundlerLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[(File, String)]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value
      val stageOutput = stage.value.data

      val mainClassValue = (mainClass in scalaJSLauncher).value.getOrElse("No main class detected")
      val launcherContent = {
        val module = JS.ref("require")(JS.str(stageOutput.absolutePath))
        val mainClassRef =
          mainClassValue
            .split('.')
            .foldLeft[Trees.Tree](module) { (tree, part) => tree.bracket(part) }
        (mainClassRef() `.` "main")()
      }
      val launcherFile = targetDir / "launcher.js"
      IO.write(launcherFile, launcherContent.show)

      (launcherFile, mainClassValue)
    }

  def scalaJSLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Attributed[VirtualJSFile]]] =
    Def.task {
      val log = streams.value.log

      val (launcherFile, mainClassValue) = scalaJSBundlerLauncher.value

      Attributed[VirtualJSFile](FileVirtualJSFile(launcherFile))(
        AttributeMap.empty.put(name.key, mainClassValue)
      )
    }

  def npmUpdateTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[File]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val bundleFile = writeBuildFilesTask(stage).value

      log.info("Updating NPM dependencies")
      run("npm update", targetDir, log)

      bundleFile
    }

  def bundleTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[File]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val bundleFile = (npmUpdate in stage).value

      log.info("Bundling the application with its NPM dependencies")
      run("npm run bundle", targetDir, log)

      bundleFile
    }

  def run(cmd: String, cwd: File, logger: Logger): Unit = {
    val process = Process(cmd, cwd)
    process !! logger
    ()
  }
}
