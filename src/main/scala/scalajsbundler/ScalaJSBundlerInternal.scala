package scalajsbundler

import org.scalajs.core.tools.io.{FileVirtualJSFile, VirtualJSFile}
import org.scalajs.core.tools.javascript.Trees
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport.{scalaJSLauncher, fastOptJS, fullOptJS, loadedJSEnv, emitSourceMaps}
import sbt.Keys._
import sbt._

import JS.syntax._

object ScalaJSBundlerInternal {

  import ScalaJSBundler.autoImport._

  // (file, mainClass)
  val scalaJSBundlerLauncher = taskKey[(File, String)]("Launcher generated by scalajs-bundler")

  private val perConfigSettings: Seq[Def.Setting[_]] =
    Seq(
      scalaJSLauncher in fastOptJS := Def.taskDyn(scalaJSLauncherTask(fastOptJS)).value,
      scalaJSLauncher in fullOptJS := Def.taskDyn(scalaJSLauncherTask(fullOptJS)).value,
      scalaJSBundlerLauncher in fastOptJS := Def.taskDyn(scalaJSBundlerLauncherTask(fastOptJS)).value,
      scalaJSBundlerLauncher in fullOptJS := Def.taskDyn(scalaJSBundlerLauncherTask(fullOptJS)).value,
      loadedJSEnv <<= loadedJSEnv.dependsOn(npmUpdate in fastOptJS),
      npmDependencies := Map.empty,
      npmDevDependencies := Map("webpack" -> (version in webpack).value),
      npmUpdate in fastOptJS := Def.taskDyn(npmUpdateTask(fastOptJS)).value,
      npmUpdate in fullOptJS := Def.taskDyn(npmUpdateTask(fullOptJS)).value,
      webpackEntries in fastOptJS := Def.taskDyn(webpackEntriesSetting(fastOptJS)).value,
      webpackEntries in fullOptJS := Def.taskDyn(webpackEntriesSetting(fullOptJS)).value,
      emitSourceMaps in (webpack in fullOptJS) := false,
      emitSourceMaps in (webpack in fastOptJS) := true,
      webpack in fastOptJS := Def.taskDyn(bundleTask(fastOptJS)).value,
      webpack in fullOptJS := Def.taskDyn(bundleTask(fullOptJS)).value
    )

  val testSettings: Seq[Setting[_]] =
    Seq(
      npmDependencies ++= (npmDependencies in Compile).value,
      npmDevDependencies ++= (npmDevDependencies in Compile).value
    )

  val projectSettings: Seq[Setting[_]] =
    Seq(
      version in webpack := "1.13",
      webpackConfigFile := None
    ) ++
    inConfig(Compile)(perConfigSettings) ++
    inConfig(Test)(perConfigSettings ++ testSettings)

  def writeBuildFilesTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[File]]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      // Create scalajs.webpack.config.js
      val scalajsConfigFile = targetDir / "scalajs.webpack.config.js"
      val scalajsConfigContent =
        JS.ref("module") `.` "exports" := JS.obj(
          "entry" -> JS.obj((webpackEntries in stage).value.map { case (key, file) =>
            key -> JS.str(file.absolutePath) }: _*
          ),
          "output" -> JS.obj(
            "path" -> JS.str(targetDir.absolutePath),
            "filename" -> JS.str("[name]-bundle.js")
          )
        )
      log.debug("Writing 'scalajs.webpack.config.js'")
      IO.write(scalajsConfigFile, scalajsConfigContent.show)


      def toJsonObject(deps: Map[String, String]): Trees.ObjectConstr =
        JS.obj(deps.mapValues(JS.str).to[Seq]: _*)

      // Create a package.json file
      val bundleCommand =
      (webpackConfigFile in stage).value match {
        case Some(configFile) =>
          val configFileCopy = targetDir / configFile.name
          IO.copyFile(configFile, configFileCopy)
          s"webpack --config ${configFileCopy.absolutePath}"
        case None =>
          s"webpack --config ${scalajsConfigFile.absolutePath}"
      }

      val packageJson =
        JS.obj(
          "dependencies" -> toJsonObject(npmDependencies.value),
          "devDependencies" -> toJsonObject(npmDevDependencies.value),
          "scripts" -> JS.obj(
            "bundle" -> JS.str(bundleCommand)
          )
        )
      log.debug("Writing 'package.json'")
      IO.write(targetDir / "package.json", JS.toJson(packageJson))

      (webpackEntries in stage).value.map { case (key, _) => targetDir / s"$key-bundle.js" }
    }

  // TODO remove as soon as they disappear from Scala.js
  def scalaJSBundlerLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[(File, String)]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value
      val stageOutput = stage.value.data

      val mainClassValue = (mainClass in (scalaJSLauncher in stage)).value.getOrElse("No main class detected")
      val launcherContent = {
        val module = JS.ref("require")(JS.str(stageOutput.absolutePath))
        val mainClassRef =
          mainClassValue
            .split('.')
            .foldLeft[Trees.Tree](module) { (tree, part) => tree.bracket(part) }
        (mainClassRef() `.` "main")()
      }
      val launcherFile = targetDir / "launcher.js"
      IO.write(launcherFile, launcherContent.show)

      (launcherFile, mainClassValue)
    }

  def scalaJSLauncherTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Attributed[VirtualJSFile]]] =
    Def.task {
      val log = streams.value.log

      val (launcherFile, mainClassValue) = (scalaJSBundlerLauncher in stage).value

      Attributed[VirtualJSFile](FileVirtualJSFile(launcherFile))(
        AttributeMap.empty.put(name.key, mainClassValue)
      )
    }

  def npmUpdateTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[File]]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val bundleFiles = writeBuildFilesTask(stage).value

      log.info("Updating NPM dependencies")
      run("npm update", targetDir, log)

      bundleFiles
    }

  def webpackEntriesSetting(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[(String, File)]]] =
    Def.task {
      val launcherFile = (scalaJSBundlerLauncher in stage).value._1

      val stageFile = stage.value.data
      val name = stageFile.name.stripSuffix(".js")
      Seq(name -> launcherFile)
    }

  def bundleTask(stage: TaskKey[Attributed[File]]): Def.Initialize[Task[Seq[File]]] =
    Def.task {
      val log = streams.value.log
      val targetDir = (crossTarget in stage).value

      val bundleFiles = (npmUpdate in stage).value

      log.info("Bundling the application with its NPM dependencies")
      run("npm run bundle", targetDir, log)

      bundleFiles
    }

  def run(cmd: String, cwd: File, logger: Logger): Unit = {
    val process = Process(cmd, cwd)
    process !! logger
    ()
  }
}
